# 网络协议

## TCP/IP UDP

### TCP/UDP

TCP/UDP是传输层协议，用于端到端的通信。在主机中，不同的进程可以用同样的协议通信，这即是传输层的复用。而当同一台主机收到消息后，可以根据其报文头部来进行解析，并将消息分发给不同的进程，这即是分用。

#### UDP特性以及报文结构

```
| sourceIP | destinationIP | sourcePort | destinationPort | UDPlength | UDPdata
```

UDP是不面向连接的协议，尽最大可能交付，没有拥塞控制，支持一对一、多对一、一对多和多对多的通信。UDP报文结构主要由三部分组成，一个是IP，一个是UDP报文头，一个是数据。IP即源端口号和目的端口号。

#### TCP特性以及报文结构

```
| sourceIP | destinationIP | sourcePort | destinationPort |
|          |               |           sequenceID         |
|          SYN    ACK      |         acknowledgeID        |
|          FIN             |             window           |
|          authsum         |            emergency*        |
```

TCP是面向连接的协议，每一条报文都要保证按照顺序传递，有流量控制、拥塞控制、滑动窗口等特性。面向字节流。只能一对一。TCP报文结构是由IP、序号、确认号、窗口大小和数据等组成的。序号SeqID、确认号AckID一个是用于对报文进行唯一标识，一个是对之前的报文序号进行回复+1的操作。

#### TCP三次握手四次挥手

TCP三次握手和四次挥手都是进行了两次主动请求和两次回复。而每次主动请求都会带有一个seq，每次回复都会带有一个一个ack的id标识。

三次握手是通信双方为了确认彼此的发送/接受消息的能力是否正常，第一次握手是客户端向服务端发起请求，发送SYN、Seq=x报文；第二次握手则是服务端向客户端发送一个报文，带有SYN、seq=y和ack=x等信息，这里的seq是为了向客户端表示自己的发送消息的能力正常，而ack是为了向客户端表明自己的接受消息的能力正常；第三次握手则是客户端向服务端请求，发送一个带有SYN、seq=x+1和ack=y+1的报文，这里的seq是客户端向服务端表明自己是第一次握手的客户端，而ack报文是客户端为了向服务端表明自己具有正常的接收消息的能力。

为什么不是四次握手或者是两次握手？是因为两次握手并不能保证彼此双方确认了对方有着正常的收发消息的能力，这里的正常收发消息，指的是在这一次双工通信中的正常收发消息的能力，在这样的确认机制之后，通信双方才会开始收发数据和等待收发数据。如果仅仅停留在三次握手的第二次之后，通信双方就开始按照TCP协议来通信，那么如果握手过程中有一次报文丢失，那么就会造成不必要的进程等待消息，这就是资源的浪费。而四次握手是没有必要的，第三次握手如果分成两次，一次表示自己具有正常接受消息能力，一次表示自己具有正常发送消息能力，那么那一次表示自己具有正常接受消息能力的握手不就已经表明自己具有发送消息能力的意义了吗？

四次挥手是彼此双方都要告诉对方，我不再发送消息，并且确认对方收到了这个信息之后也不再接收对方的消息的过程。四次挥手中，第一次挥手是客户端向服务端发送一个带有seq=x、ack=y和FIN的报文，代表我停止发送消息了，进入FIN_WAIT_1状态；然后第二次挥手是服务端向客户端发送一个带有ack=x+1的报文；第三次是服务端向客户端发送一个带有seq=y+1、FIN的报文，进入LAST_ACK状态；第四次是客户端向服务端发送一个带有ack=y+2的报文，进入2MS状态。

为什么要有2MS状态，是因为一个报文在网络中最大存活时间就是2MS，如果过了这个时间还没有收到服务端的再一次FIN消息，代表服务端成功收到了这个消息，这个消息没有从网络中丢失；而且经过这个时间之后，本次连接的所有报文都在网络中消失了，下一次再由客户端发起的请求不会再收到来自此次连接的保温了。

#### TCP可靠传输如何实现

序列号/ack机制、检验和、流量控制、滑动窗口、超时重传。

#### 滑动窗口

对于发送方内的任一报文，都可以分为"已经发送并得到ack"、"已经发送未得到ack"、"未发送但对方允许发送的"和"未发送并且对方不允许发送的"四种报文。而滑动窗口由中间的两种报文组成。

对于接收方内的报文，可以分成"已接收"、"未接收但准备接收"和"未接收且不准备接收"的三种消息。

窗口大小由接收方TCP报文中的windows大小决定，而窗口如何滑动、何时滑动，由接收方的已确认序列号决定。滑动窗口的基本可靠性来自于确认重传机制，而滑动窗口只有在所有的段都确认的情况下才会移动左窗口。

#### 拥塞控制

因为包数量过多会导致路由器溢出而丢包，所以tcp中会用一些算法来控制发送/接收双方的发送包速度。常见有慢启动、快速重传、拥塞避免和快速恢复等算法。

## HTTP/HTTPS

HTTP协议是服务端和客户端进行通信的协议，在最开始是使用在网页端。HTTP全称是Hyper Text Transfer Protocol，超文本传输协议。所以HTTP中的许多特性，包括缓存、请求头等，不仅仅是为了调用接口使用，而且是为了前端获取静态资源使用。HTTP是无状态的，即两次请求之间在HTTP协议的语义中是没有关系的。

### HTTP请求

```
| Protocol | URL | method |
|         Headers         |
|          body           |
```

URL由`protocol:host/path?params`构成。

HTTP请求和相应都有头部数据。

### HTTP请求方法

GET POST PUT DELETE HEAD OPTIONS PATCH TRACE CONNECT

#### GET和POST的区别

GET和POST从语义上来说，一个是请求指定的页面信息，一个是向服务端提交数据进行请求处理。从语义上来说，一个是"获取"，一个是"提交"，一个将请求参数放在url中，一个将请求参数放在请求body中。但是实际上两种请求是一样的，GET也可以把请求放在body中，POST也可以把请求放在url中。而这两种请求在实现上唯一的不同是GET请求传输一个TCP数据包，POST传输两个数据包。

#### 其余请求方法

OPTIONS用于查看服务器支持的所有请求方法，HEAD请求只获取请求头。

### HTTP各个版本

#### HTTP0.9

已过时，只支持GET方法。

#### HTTP1.0

必须包含请求头，多了POST和HEAD命令。

### HTTP缓存

