# 动态规划

​		时间和空间由无数个点连接起来，也可以说，只是由前一个点、当前的点和后一个点连接起来。

## 引言

​		我在学习算法和做编程算法题的时候，经常会看到"动态规划"这个词，久而久之发现这是学习计算机算法知识中很重要的一个知识点。在学习的过程中，我自己总结了一些心得，在这里把对动态规划思想的心得体会写下来。

​		动态规划，在我看来，就是在处理算法问题的时候，在推导"未来"的时候，只考虑"现在"，而不考虑"过去"。说得直白一点，就是将算法问题分割成一个又一个的阶段，然后在推导得出最终的结果的时候，所考虑的参数只是前一个阶段的参数，在更久以前的参数与最终结果的推导无关。

​		上述是我对动态规划的简单理解，下面以一些例子来具体解释。

## 裴波那契数列

​		在数学上，裴波那契数列以如下被递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）。在这个数列中，从第三项开始，每一项都等于前两项之和。

​		在算法题中，我遇到过很多次求解裴波那契数列的题目，这道题不算难，但是算是比较常见和经典的题目了。题目一般是要求裴波那契的第N个数字，比较简单粗暴的解法是用递归法，如下：

```python
def Fibonacci(n):
    if n == 1 or n == 2:
        return 1
    return Fibonacci(n - 1) + Fibonacci(n - 2)
```

​		在这种方法中，用递归的方法，在算F(n)的时候，去算F(n-1)和F(n-2)，而在计算F(n-1)和F(n-2)的时候，又以相同的思想去计算F(n-2)、F(n-3)与F(n-3)和F(n-4)。在我列出这几个值的时候，有一个问题就已经出现了，那就是在递归的时候，每次都要递归计算的话，有一些数值是重复计算了，比如F(n-2)和F(n-3)就计算了两次，而理论上每个值应该只计算一次。即理论上这个算法应该耗费的时间复杂度是O(n)，但是实际上耗费的时间复杂度是O(n!)；理论上这个方法应该耗费的空间复杂度是O(1)，但是实际上耗费的空间复杂度是O(n)。

​		这个方法当然是比较愚蠢的方法，对于很多人来说也意识到了可以有更好的方法，但是我把它放到动态规划的文章里提到的原因是想竖起一个反面例子。我想说明的就是：其实计算裴波那契数列第N项只需要前两项作为参数，但是在这个方法中将之前所有的项都拿来做参数，当然会造成不必要的计算，也浪费了内存。

​		这种方法当然有优化的方式，那就是将每次计算出的F(n-1)和F(n-2)记录下来，进行循环计算，如下：

```python
def Fibonacci(n):
    a = b = 1
    result = 0
    if n == 1 or n ==2:
        return 1
    for count in range(2, n):
        result = a + b
        a = b
        b = result
    return result
```

​		可以看出，时间复杂度O(n), 空间复杂度O(1)。

​		方法很简单，很多人都会，我想说的重点是优化的思想。在后一种方法中，我们计算最终的值的时候，考虑到的参数确确实实地只有裴波那契数列中这个数的前两个数。在这个过程中，我们的优化思想是：计算出"未来"结果的方程中，永远只有"当前"的状态，而"过去"的状态只是构成"当前"的因素，却与"未来"无关。

​		这就是我所理解的动态规划的思想，解决一个问题的算法的执行，实质上也是一个时间和空间的变化。在我们看来，时间和空间是由无数个点连接而成的，但是，我们永远只处于时间和空间的一个点中，连接我们所处的时间和空间的因素，其实永远只有上一个点和下一个点。总结成动态规划的思想就是：我们只用”当前“的状态去计算”未来"的状态，而在整个过程中，每一个"当前"的状态，都是由"过去"的状态计算出来的，在认识到整个过程连接的完整性后，我们就可以动态地用初始值不断地计算出最终结果。

## 动态规划中"阶段"的概念

​		要理解动态规划，在我看来只需要理解"阶段"这个概念就可以了。

​		首先说明，我在上面所说的时间空间的陈述并不能说明所有问题都可以用动态规划来解决。

​		那么什么是阶段呢？我们来看下一个例子：

​		给一个由数字组成的矩阵，初始在左上角，要求每次只能向下或向右移动，路径和就是经过的数字全部加起来，求可能的最小路径和。

```
1   2   5   8   9
4   3   2   8   7
6   8   3   4   1
9   2   3   8   2
4   6   5   7   6
```

​		解决这个问题应该用什么方法呢？我在遇到这个问题的时候没有什么创新能力，只能想出暴力遍历法和动态规划法。

暴力遍历的方法不用过多赘述，我讲一下动态规划的方法。

​		题目给出的矩阵中，在每一个点都可以找出一个从起始点到这个点的最小路径。那么从这一点就可以看出，在走到终点之前的那个点，由起始点走到它那里的路径绝对是最小值，以此类推，在最优解中，每两个点之间的连接都是可以求出来的路径最小值。那么我们可以这么认为，从起始点开始，可以求出到达每个点的最小路径，甚至可以说，可以逐步求出到最终点的最小路径。

​		到达每个点的上一个点要么是位于它上面的点，要么是位于它左边的点，因为是矩阵，所以我们不按照点来循环，而是按照列或者行来循环，如下：

```python
def MinRoute(a):
    m = len(a)
    n = len(a[0])

    s = np.zeros((m, n), dtype=np.int)  # import numpy as np

    for i in range(m):
        for j in range(n):
            if i == 0 or j == 0:
                temp = max(s[i - 1][j], s[i][j - 1])
            else:
                temp = min(s[i - 1][j], s[i][j - 1])
            s[i][j] = temp + a[i][j]

    return s[-1][-1]
```

​		一开始我们声明一个矩阵为s，初始值为0，按行循环，对每一行的每一列的数字进行计算，从第一个数开始，计算初始值到这个点的最小路径并保存到s中，这样一直计算下去，每次计算到一个点的最小路径不需要从头计算所有值，而是只需要计算它上一个和左边的数值就可以得出到达它的最小值。

​		这里就可以看出，到达每一个点的