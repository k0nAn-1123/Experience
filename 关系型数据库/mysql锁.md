# MySQL事务及锁机制

## 事务

### 特性

- 原子性

  事务中的所有操作，要么全部完成，要么都不完成，不会有操作完成一半的情况发生。在操作执行错误的时候，所有数据会回滚到事务执行之前的状态。事务是一个不可分割的最小单元，而不是事务中的一些小操作。everything or nothing

  事务的原子性是基于`Redo/Undo`机制的，`Redo log`用来记录某数据块被修改后的值，可以用来恢复未写入 data file 的已成功事务更新的数据；`Undo log`是用来记录数据更新前的值，保证数据更新失败能够回滚。

- 一致性

  事务开始前和事务结束后，数据库的完整性没有改变。事务的执行应该让数据库从一个一致状态转换到另一个一致状态。

- 隔离性

  事务中所有的操作和修改，在最终完成和提交以前，对其他事务是不可见的。即在事务执行完成之前，其他事务是不能读到这一项事务中修改的结果的。

- 持久性

  事务一旦提交，修改完成后的结果和普通操作一样是持久存在于数据库中的。

### 隔离级别

隔离级别从低到高有四种：Read uncommitted 、Read committed 、Repeatable read 、Serializable。

- Read uncommitted

  读未提交，一个事务可以读取另一个事务未提交的数据。这里出现了一个**脏读**的现象，即A事务读取到了B事务未提交的数据，而这个数据有可能并不是B事务最终要提交的结果，所以这样的隔离级别是很低的，要解决**脏读**就要看下一个隔离级别。

- Read committed

  读提交，一个事务要等另一个事务提交后才能读取到事务提交的结果。但是这样会出现**不可重复读**的问题，即A事务在B事务提交前读取到的数据和B事务提交后读取到的数据是不一样的，那么两个不一样的数据在A事务执行过程中会导致读取和修改操作的错误。

- Repeatable read

  重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。但是这一种隔离级别不允许的操作是修改(UPDATE)而不是插入(INSERT)，即A事务开始后(开始读取)，如果B事务要对数据进行修改(UPDATE)是不被允许的，但是B事务新增(INSERT)数据是可以的，那么还是会导致A事务中读到不一致的数据，这种现象叫做**幻读**。

- Serializable

  序列化，最高的事务隔离级别，事务串行化顺序执行，可以避免脏读、不可重复读和幻读。但是这种隔离级别的效率十分低下，

MySQL的默认隔离级别是Repeatable read。

### 设置隔离级别

1. 在my.ini中使用transaction-isolation来设置服务器的缺省事务隔离级别。

   ```
   – READ-UNCOMMITTED
   – READ-COMMITTED
   – REPEATABLE-READ
   – SERIALIZABLE
   
   •   例如：
   [mysqld]
   transaction-isolation = READ-COMMITTED
   ```

2. 通过命令动态设置隔离级别

   ```
       SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL <isolation-level>
       其中的<isolation-level>可以是：
   –   READ UNCOMMITTED
   –   READ COMMITTED
   –   REPEATABLE READ
   –   SERIALIZABLE
   •   例如： SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
   ```

## MySQL 锁

### 乐观锁 悲观锁

乐观锁用数据版本(version)或者是时间戳(timestamp)实现，在读取数据的时候默认数据不会被别人修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有更新这个数据。乐观锁适用于**读多写少**的场景，这样可以提高吞吐量。

悲观锁和乐观锁不同，在每次读取数据的时候都认为别人会修改，所以在读取数据的时候都会上锁。这样在操作过程中，数据就会上锁，别人就需要等待直到相关操作完成。

### 并发控制 共享锁 排他锁

悲观锁中包括了共享锁和排他锁。

共享锁，也称为读锁，允许多个连接可以同一时刻并发的读取同一资源，互不干扰。

排他锁也称为写锁，一个写锁会阻塞其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。

### 行锁 页锁 表锁

